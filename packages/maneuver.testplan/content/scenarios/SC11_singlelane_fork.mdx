---
title: Single Lane w/ Fork
---

# Situation Overview

Route is a single lane with a fork, route guidance is turn right.
This scenario tests that NV takes the right (or left) fork.

<Svg src='svg/guide.fork.tgt-right.comp.svg' width="100" height="300"/>

<FeatMap>

## route

- lanes = ['C']
- road.fork(lane: C)
- **RGTakeRight**

## virtual lane

- push fork.right to lane queue

## strategy

- **SRContinueOn**

## decision

- **LaneKeepSame**

## execution

- LaneKeepSameProcedure

</FeatMap>

# Scenarios

- SingleLane.RoadFork.RGTakeRight
- SingleLane.RoadFork.RGTakeLeft

## SingleLane.RoadFork.RGTakeRight

```bash
duration 60s
declare extern $starting_speed defaulted to 50kmph

road {
    road.lanes(C)
    $f  = road.fork(lane: C, from: $nl, dist: 300m)
}

nv:
    speed: $starting_speed

["nv takes right fork"] {

    do {
        nv.guide(inst: continueOn, to: $f.right, when ($f at 100m))
        $ev_at_fr = nv.on_lane_change(to: $f.right)
    }
    until {
        @$ev_at_fr(end)
    }

    assert {
        nv.lane == $f.right
    }
}
```

## SingleLane.RoadFork.RGTakeLeft

```bash
duration 60s
declare extern $starting_speed defaulted to 50kmph

road {
    road.lanes(C)
    $f  = road.fork(lane: C, from: $nl, dist: 300m)
}

nv:
    speed: $starting_speed

["nv takes left fork"] {

    do {
        nv.guide(inst: continueOn, to: $f.left, when ($f at 100m))
        $ev_at_fl = nv.on_lane_change(to: $f.left)
    }
    until {
        @$ev_at_fl(end)
    }

    assert {
        nv.lane == $f.left
    }
}
```

```python

from fsd import ElementType


class NV(ElementType):
    NUM_ENTRIES_X = 70
    NUM_ENTRIES_Y = 10
    BB_WIDTH_LIST = [4]
    BB_HEIGHT_LIST = [8]

    def __init__(self):
        super().__init__()
        for x in range(0, NV.NUM_ENTRIES_X):
            for y in range(0, NV.NUM_ENTRIES_Y):
                self.addGridEntry(x, y)
        self.declareRules()

    def addGridEntry(self, x, y):
        iGridMatchDepth = self.addIndicator('iGE_x{}_y{}'.format(x, y))
        for n in ['close', 'not_close', 'middle', 'not_middle', 'far', 'not_far']:
            self.addSymptom(n, indicator=iGridMatchDepth, flagMap='Range')

    def getSymptomSet(self, x, y, depth):
        return self.symptoms['iGE_x{}_y{}{}{}'.format(x, y, depth[0].upper(), depth[1:])]

    def getSymptomReset(self, x, y, depth):
        return self.symptoms['iGE_x{}_y{}Not_{}'.format(x, y, depth)]

    def declareRules(self):
        rc = {}
        for bb_x in range(0, NV.NUM_ENTRIES_X):
            for bb_y in range(0, NV.NUM_ENTRIES_Y):
                for width in NV.BB_WIDTH_LIST:
                    if bb_x + width <= NV.NUM_ENTRIES_X:
                        for height in NV.BB_HEIGHT_LIST:
                            if bb_y + height <= NV.NUM_ENTRIES_Y:
                                for depth in ['close', 'middle', 'far']:
                                    bb = 'bb_x{}_y{}_{}x{}_{}'.format(
                                        bb_x, bb_y, width, height, depth)
                                    rc_list = []
                                    for x in range(max(0, bb_x - 1),
                                                   min(NV.NUM_ENTRIES_X, bb_x + width + 1)):
                                        for y in range(max(0, bb_y - 1),
                                                       min(NV.NUM_ENTRIES_Y, bb_y + height + 1)):
                                            if x < bb_x or x >= bb_x + width or y < bb_y or y >= bb_y + height:
                                                rc_list.append(self.getSymptomReset(x, y, depth))
                                            else:
                                                rc_list.append(self.getSymptomSet(x, y, depth))
                                    rc[bb] = rc_list
        self.addRootCauses(rc)

```
